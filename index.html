<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Reasoning Search Flow</title>
  <style>
    :root { --bg:#f8fafc; --ink:#111827; --arrow:#94a3b8; --accent:#fb923c; }
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial;background:var(--bg);color:var(--ink)}
    .wrap{width:100%;margin:24px auto;padding:0}
    .panel{ display:flow-root; margin-bottom:0; }
    .hint{color:#475569;font-size:14px;margin-top:8px;text-align:center}
    .token{filter:drop-shadow(0 1px 2px rgba(0,0,0,.35));offset-rotate:0deg}
    .sub{ margin: 6px 0 8px; }
    #scene{ display:block; margin:0; }
    @keyframes move{from{offset-distance:0%}to{offset-distance:100%}}
  </style>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Best-of-N Search</title>
  <style>
    :root{--bg:#f8fafc;--ink:#0f172a;--arrow:#cbd5e1;--good:#22c55e;--bad:#f43f5e;--node:#bae6fd;--token:#3b82f6}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial}
    h1{margin:18px 0 6px;text-align:center;font-size:22px}
    .wrap{max-width:1200px;margin:0 auto;padding:0 12px 16px}
    svg{display:block;width:100%;height:380px}
    .node{filter:drop-shadow(0 2px 4px rgba(0,0,0,.08))}
    .token{r:10;fill:var(--token);filter:drop-shadow(0 1px 2px rgba(0,0,0,.35))}
    @keyframes travel{from{offset-distance:0%}to{offset-distance:100%}}
    .pulse{animation:pulse 1.2s ease-in-out infinite}
    @keyframes pulse{0%{opacity:.6}50%{opacity:1}100%{opacity:.6}}
    button.run-btn{display:block;margin:0 auto 12px;padding:8px 16px;font-size:14px;border:1px solid #d1d5db;border-radius:6px;background:#fff;cursor:pointer}
    button.run-btn:hover{background:#f3f4f6}
    /* Unfold animation for arrows */
    .edge{stroke:var(--arrow);stroke-width:3;fill:none}
    .edge.draw{transition:stroke-dashoffset 800ms ease}
    .fin{opacity:0;transform-box:fill-box;transform-origin:center;}
    .fin.show{opacity:1;transition:opacity .4s ease, transform .4s ease;transform:scale(1.05)}
  </style>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Beam Search</title>
  <style>
    :root{
      --bg:#f8fafc; --ink:#0f172a; --muted:#64748b;
      --arrow:#cbd5e1; --node:#bae6fd; --token:#3b82f6;
      --good:#22c55e; --bad:#f43f5e;
    }
    body{margin:0;background:var(--bg);color:var(--ink);
        font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial}
    h1{margin:18px 0 6px;text-align:center;font-size:22px}
    .sub{margin:0 0 8px;text-align:center;color:var(--muted);font-size:14px}
    .wrap{max-width:1200px;margin:0 auto;padding:0 12px 16px}
    svg{display:block;width:100%;height:420px}
    .node{filter:drop-shadow(0 2px 4px rgba(0,0,0,.08))}
    .edge{stroke:var(--arrow);stroke-width:3;fill:none}
    .edge.draw{transition:stroke-dashoffset 700ms ease}
    .mid{fill:#e5e7eb}
    .mid.good{fill:var(--good)}
    .mid.bad{fill:var(--bad);opacity:.9}
    .leaf{fill:#e5e7eb}
    .leaf.good{fill:var(--good)}
    .leaf.bad{fill:var(--bad);opacity:.95}
    .pulse{animation:pulse 1.2s ease-in-out infinite}
    @keyframes pulse{0%{opacity:.65}50%{opacity:1}100%{opacity:.65}}
    @keyframes travel{from{offset-distance:0%}to{offset-distance:100%}}
  </style>

  <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Diverse Verifier Tree Search — Dynamic Visualization</title>
    <style>
      :root{
        --bg:#f8fafc; --ink:#0f172a; --muted:#64748b;
        --arrow:#cbd5e1; --node:#bae6fd; --token:#3b82f6;
        --good:#22c55e; --bad:#f43f5e;
      }
      body{margin:0;background:var(--bg);color:var(--ink);
          font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial}
      h1{margin:18px 0 6px;text-align:center;font-size:22px}
      .sub{margin:0 0 8px;text-align:center;color:var(--muted);font-size:14px}
      .wrap{max-width:1200px;margin:0 auto;padding:0 12px 16px}
      svg{display:block;width:100%;height:420px}
      .node{filter:drop-shadow(0 2px 4px rgba(0,0,0,.08))}
      .edge{stroke:var(--arrow);stroke-width:3;fill:none}
      .edge.draw{transition:stroke-dashoffset 700ms ease}
      .token{fill:var(--token);r:8;filter:drop-shadow(0 1px 2px rgba(0,0,0,.35))}
      .mid{r:10}
      .mid.good{fill:var(--good)}
      .mid.bad{fill:var(--bad);opacity:.9}
      .leaf{r:12}
      .leaf.good{fill:var(--good)}
      .leaf.bad{fill:var(--bad);opacity:.95}
      .pulse{animation:pulse 1.2s ease-in-out infinite}
      @keyframes pulse{0%{opacity:.65}50%{opacity:1}100%{opacity:.65}}
      @keyframes travel{from{offset-distance:0%}to{offset-distance:100%}}
  </style>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Strategies Performance Comparison</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica Neue,Arial;background:#f8fafc;color:#0f172a}
    h1{text-align:center;margin:18px 0 6px;font-size:22px}
    #chart{display:block;margin:0 auto;max-width:900px}
    .axis path,.axis line{stroke:#94a3b8}
    .baseline{stroke:#475569;stroke-dasharray:6 6;opacity:.8}
    .legend text{font-size:12px;dominant-baseline:middle;fill:#0f172a}
  </style>

  <meta charset="UTF-8">
  <title>Benchmarks</title>
  <!-- DataTables + jQuery -->
  <link rel="stylesheet" href="https://cdn.datatables.net/1.13.4/css/jquery.dataTables.min.css">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.datatables.net/1.13.4/js/jquery.dataTables.min.js"></script>
  
  <meta charset="UTF-8">
  <style>
    .hanoi-section {
      font-family: sans-serif;
      background: #fefefe;
      padding: 2rem;
      text-align: center;
    }
    .peg-container {
      display: flex;
      justify-content: space-around;
      align-items: flex-end;
      height: 200px;
      margin-top: 3rem;
    }
    .peg {
      width: 10px;
      height: 150px;
      background: #333;
      position: relative;
    }
    .disk {
      position: absolute;
      height: 20px;
      border-radius: 5px;
      left: 50%;
      transform: translateX(-50%);
    }
    .disk1 { width: 100px; background: #FF6B6B; }
    .disk2 { width: 70px; background: #4ECDC4; }
    .disk3 { width: 40px; background: #1A535C; }

    .peg-label {
      margin-top: 1rem;
      font-weight: bold;
    }
  </style>
</head>

<body>

  <h1 style="text-align:left">Reasoning Architecture</h2>
  <h2>Pipeline</h2>

  <p>
    While DeepSeek R1 is a dedicated reasoning model trained with chain-of-thought data and methods such as
    supervised fine-tuning and reinforcement learning, it's also possible to build a reasoning architecture around a
    standard language model.
  </p>

  <p>
    In this setup, an LLM (e.g., a Llama 1B or 8b model) produces multiple candidate answers. A reward model then
    scores these candidates, and a search strategy selects the best answer based on the rewards. This kind of architecture is described 
    in the Hugging Face cookbook:
    <a href="https://huggingface.co/learn/cookbook/search_and_learn" target="_blank" rel="noopener">“Search &amp; Learn”</a>.
  </p>

  <p>
    The dynamic chart below visualizes the architecture: the LLM proposes candidates, the reward model scores them, and the search strategy
    steers the loop toward the final answer.
  </p>

<div class="wrap">
  <h3 style="text-align:center">Reasoning Search Flow</h3>
  <div class="panel">
    <p class="sub">Gets a problem → produce answers → score answers - choose the best with the strategy - give final answer.</p>
    <svg id="scene"
     viewBox="0 0 1200 350"
     width="100%"
     height="350"
     preserveAspectRatio="xMidYMin meet">
      <defs>
        <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="userSpaceOnUse">
          <path d="M0,0 L9,3 L0,6 Z" fill="var(--arrow)" />
        </marker>
        <filter id="soft" x="-50%" y="-50%" width="200%" height="200%">
          <feGaussianBlur in="SourceGraphic" stdDeviation="3" />
        </filter>
      </defs>

      <script type="application/json" id="points">{
        "math": {"x":90,  "y":320},
        "llm":  {"x":400, "y":260},
        "prm":  {"x":700, "y":260},
        "search":{"x":620, "y":100 },
        "final": {"x":1070,"y":350}
      }</script>

      <g id="edges" stroke="var(--arrow)" stroke-width="3" marker-end="url(#arrow)" opacity=".65" fill="none"></g>
      <g id="nodes"></g>
      <circle cx="620" cy="100" r="62" fill="var(--accent)" opacity=".15" filter="url(#soft)" />
      <g id="tokenLayer"></g>
    </svg>
  </div>
</div>

<script>
(function(){
  const P = JSON.parse(document.getElementById('points').textContent);
  const svgNS = 'http://www.w3.org/2000/svg';
  const rightOf = (p)=>[p.x+90,p.y];
  const leftOf  = (p)=>[p.x-90,p.y];
  const topOf   = (p)=>[p.x,p.y-40];
  const C = (x1,y1,x2,y2,x,y)=>`C ${x1} ${y1}, ${x2} ${y2}, ${x} ${y}`;
  const seg=(from,to,bendY)=>{const midX=(from[0]+to[0])/2,by=bendY??from[1];return `M ${from[0]} ${from[1]} ${C(midX,by,midX,by,to[0],to[1])}`};

  const paths={
    mathToLLM: seg(rightOf(P.math), leftOf(P.llm)),
    llmToPRM: seg(rightOf(P.llm), leftOf(P.prm)),
    prmToSearch: seg(rightOf(P.prm), [P.search.x, P.search.y], P.prm.y - 80),
    searchToLLM: seg([P.search.x-90,P.search.y],[P.llm.x,P.llm.y-40], P.search.y-30),
    prmToFinal: seg(rightOf(P.prm), leftOf(P.final))
  };

  function addNode(group,x,y,label,fill){
    const g=document.createElementNS(svgNS,'g');
    g.setAttribute('transform',`translate(${x-90},${y-40})`);
    const rect=document.createElementNS(svgNS,'rect');
    rect.setAttribute('rx','18');rect.setAttribute('width','180');rect.setAttribute('height','80');
    rect.setAttribute('fill',fill);rect.setAttribute('style','filter:drop-shadow(0 1px 2px rgba(0,0,0,.15))');
    const text=document.createElementNS(svgNS,'text');
    text.setAttribute('x','90');text.setAttribute('y','44');text.setAttribute('text-anchor','middle');
    text.setAttribute('fill','#111827');text.setAttribute('style','font-weight:600');
    text.textContent=label;
    g.appendChild(rect);g.appendChild(text);group.appendChild(g);
  }

  const nodesG=document.getElementById('nodes');
  addNode(nodesG,P.math.x,P.math.y,'Input problem','#bae6fd');
  addNode(nodesG,P.llm.x,P.llm.y,'LLM','#d8b4fe');
  addNode(nodesG,P.prm.x,P.prm.y,'PRM','#fef08a');
  addNode(nodesG,P.search.x,P.search.y,'Search strategy','#fdba74');
  addNode(nodesG,P.final.x,P.final.y,'Final answer','#bae6fd');

  const edgesG=document.getElementById('edges');
  Object.values(paths).forEach(d=>{const path=document.createElementNS(svgNS,'path');path.setAttribute('d',d);edgesG.appendChild(path);});

  const tokens=[
    {d:paths.mathToLLM, delay:0.0, color:'#3b82f6'},
    {d:paths.llmToPRM, delay:0.0, color:'#7c3aed'},
    {d:paths.prmToSearch, delay:0.0, color:'#f59e0b'},
    {d:paths.searchToLLM, delay:0.0, color:'#10b981'},
    {d:paths.prmToFinal, delay:0.0, color:'#22c55e'}
  ];

  const tokenLayer=document.getElementById('tokenLayer');
  tokens.forEach(t=>{
    const c=document.createElementNS(svgNS,'circle');
    c.setAttribute('r','10');
    c.setAttribute('fill',t.color);
    c.classList.add('token');
    c.style.offsetPath=`path('${t.d}')`;
    c.style.animation=`move 4s linear ${t.delay}s infinite`;
    c.style.animationPlayState='running';
    tokenLayer.appendChild(c);
  });
})();
</script>

<p>
    To reproduce the pipeline one can use the Search-and-Learn repository: <a href="https://github.com/huggingface/search-and-learn" 
    target="_blank" rel="noopener">huggingface/search-and-learn</a>.</p> 
    <p>
    Clone the repository, install dependencies as described in the repo, follow the 
    pipeline guide in the cookbook: <a href="https://huggingface.co/learn/cookbook/search_and_learn" target="_blank" rel="noopener">
      Search &amp; Learn tutorial</a>. </p>

<h2 style="margin:1.25rem 0 0.5rem 0; font-size:1.25rem; font-weight:700;">Search Strategies</h2>

  <p>There are several search strategies to select the best answer including Best-of-N, Beam Search and Diverse Verifier Tree. Let's have a closer look at them</p>

<h3 style="margin:1.25rem 0 0.5rem 0; font-size:1.25rem; font-weight:700;">Best-of-N</h3>

  <p>The Best-of-N strategy is a simple but powerful way to improve the quality of responses from a language model. </p>
    
    <p>Instead of relying on a single output, the model generates N different candidate answers to the same problem. </p>
    <p>Each candidate is then evaluated to measure how good or useful it is. Finally, the system selects the candidate with 
    the highest score.</p>

<div class="wrap">
  <h3 style="text-align:center">Best-of-N Search</h3>
  <p class="sub">Generate N candidate answers → score each → select the one with the highest reward.</p>
  <svg id="bon" viewBox="0 0 1200 400"></svg>
</div>

<script>
function startViz(){
  const N = 5;                 // number of candidates
  const CYCLE_S = 4;           // seconds per winner refresh
  const DRAW_MS = 800;         // ms it takes to draw one arrow
  const STAGGER_MS = 180;      // ms between arrow starts

  const svg = document.getElementById('bon');
  svg.innerHTML = '';
  const NS = 'http://www.w3.org/2000/svg';

  // Layout
  const cx = 600, cy = 80;            // math problem center
  const leafY = 300;                   // y for final answers
  const span = 700;                    // horizontal spread for leaves
  const leftX = cx - span/2, step = span/(N-1);

  // Problem node
  const gProb = document.createElementNS(NS,'g');
  gProb.setAttribute('transform',`translate(${cx-80},${cy-28})`);
  const rProb = document.createElementNS(NS,'rect');
  rProb.setAttribute('width',160); rProb.setAttribute('height',56); rProb.setAttribute('rx',18); rProb.setAttribute('fill','var(--node)'); rProb.setAttribute('class','node');
  const tProb = document.createElementNS(NS,'text'); tProb.setAttribute('x',80); tProb.setAttribute('y',34); tProb.setAttribute('text-anchor','middle'); tProb.textContent='Math problem';
  gProb.appendChild(rProb); gProb.appendChild(tProb); svg.appendChild(gProb);

  const finals = [], balls = [], edges = [];

  for(let i=0;i<N;i++){
    const x = leftX + i*step;
    const start = [cx, cy+28];
    const end = [x, leafY];
    const midX = (start[0]+end[0])/2;
    const bendY = cy + 40;
    const d = `M ${start[0]} ${start[1]} C ${midX} ${bendY}, ${midX} ${bendY}, ${end[0]} ${end[1]}`;

    // Edge path (to be drawn later)
    const p = document.createElementNS(NS,'path');
    p.setAttribute('d', d); p.setAttribute('class','edge draw');
    svg.appendChild(p); edges.push(p);

    // Final nodes (show after edge draws)
    const fin = document.createElementNS(NS,'circle');
    fin.setAttribute('cx', end[0]); fin.setAttribute('cy', end[1]); fin.setAttribute('r', 14); fin.setAttribute('fill', '#e5e7eb');
    fin.setAttribute('class','fin');
    svg.appendChild(fin); finals.push(fin);

    // Moving token (start after its edge finishes drawing)
    const ball = document.createElementNS(NS,'circle');
    ball.setAttribute('class','token');
    ball.style.offsetPath = `path('${d}')`;
    svg.appendChild(ball); balls.push(ball);
  }

  // Animate drawing of each edge with stroke-dasharray
  edges.forEach((path, idx)=>{
    const len = path.getTotalLength();
    path.style.strokeDasharray = `${len}`;
    path.style.strokeDashoffset = `${len}`; // hidden
    const startAt = idx*STAGGER_MS;
    setTimeout(()=>{
      path.style.strokeDashoffset = '0'; // draw
      // show final node
      finals[idx].classList.add('show');
      // start the token along this path slightly after drawing begins
      const delayForBall = 0.65*DRAW_MS; // ms
      setTimeout(()=>{
        balls[idx].style.animation = `travel ${Math.max(1200, DRAW_MS*2)/1000}s linear 0s infinite`;
      }, delayForBall);
    }, startAt);
  });

  function pickWinner(){
    const winner = Math.floor(Math.random()*N);
    finals.forEach((f,i)=>{
      if(i===winner){ f.setAttribute('fill','var(--good)'); f.classList.add('pulse'); }
      else { f.setAttribute('fill','var(--bad)'); f.classList.remove('pulse'); }
    });
  }

  // first pick after all edges have drawn once
  const totalDrawTime = (N-1)*STAGGER_MS + DRAW_MS + 200;
  setTimeout(()=>{ pickWinner()}, totalDrawTime);
}

// ---- Auto-start when the chart scrolls into view ----
document.addEventListener('DOMContentLoaded', () => {
  const target = document.getElementById('bon');
  if (!('IntersectionObserver' in window)) {
    // Fallback: start immediately
    startViz();
    return;
  }
  const obs = new IntersectionObserver(
    entries => {
      if (entries[0].isIntersecting) {
        startViz();
        obs.disconnect(); // run only once
      }
    },
    { threshold: 0.25 }
  );
  obs.observe(target);
});
</script>

<h3 style="margin:1.25rem 0 0.5rem 0; font-size:1.25rem; font-weight:700;">Beam Search</h3>

  <p>Beam Search is a structured search strategy designed to explore multiple solution paths in parallel. </p>
    
    <p>The model generates several possibilities, known as beams.</p>
    <p>At each level, these beams are evaluated and only the top-scoring ones are retained for further expansion.</p>
   <p>This pruning ensures the search stays tractable while still covering a diverse set of promising candidates.</p>


<div class="wrap">
  <h1>Beam Search</h1>
  <p class="sub">N beams → keep top-M mid-steps → expand only those → pick best final answer.</p>
  <svg id="beam" viewBox="0 0 1200 400"></svg>
</div>

<script>
function startBeam(){
  const NS  = 'http://www.w3.org/2000/svg';
  const svg = document.getElementById('beam');
  if (!svg || svg.dataset.started === '1') return; // guard: run once
  svg.dataset.started = '1';
  svg.innerHTML = '';

  // ---- Tunables ----
  const N = 5;            // first-layer beams
  const M = 2;            // beam width (survivors at intermediate)
  const CHILDREN = 2;     // children per surviving mid-step
  const DRAW_MS = 700;    // time to draw one edge
  const STAGGER_MS = 150; // delay between sibling edges
  const BALL_MS = 1400;   // token travel time per edge

  // ---- Layout ----
  const root  = {x:600, y:70};
  const y1    = 180;      // intermediate layer
  const y2    = 320;      // leaves
  const span1 = 560;      // spread for first layer
  const span2 = 360;      // spread per subtree

  // Root node
  const gRoot = document.createElementNS(NS,'g');
  gRoot.setAttribute('transform',`translate(${root.x-80},${root.y-28})`);
  const r = document.createElementNS(NS,'rect');
  r.setAttribute('width',160); r.setAttribute('height',56); r.setAttribute('rx',18);
  r.setAttribute('fill','var(--node)'); r.setAttribute('class','node');
  const t = document.createElementNS(NS,'text');
  t.setAttribute('x',80); t.setAttribute('y',34); t.setAttribute('text-anchor','middle');
  t.textContent = 'Math problem';
  gRoot.appendChild(r); gRoot.appendChild(t); svg.appendChild(gRoot);

  // Helpers
  const pathD = (x1,y1,x2,y2) => {
    const midX = (x1+x2)/2, bendY = (y1+y2)/2;
    return `M ${x1} ${y1} C ${midX} ${bendY}, ${midX} ${bendY}, ${x2} ${y2}`;
  };
  const drawEdge = (d) => {
    const p = document.createElementNS(NS,'path');
    p.setAttribute('d', d); p.setAttribute('class','edge draw'); svg.appendChild(p);
    const len = p.getTotalLength();
    p.style.strokeDasharray = `${len}`;
    p.style.strokeDashoffset = `${len}`;
    return {path:p, len};
  };
  const animateDraw = (edge, delay=0) => {
    setTimeout(()=>{ edge.path.style.strokeDashoffset='0'; }, delay);
  };
  const token = (d, delay=0) => {
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('class','token');
    c.setAttribute('r','8');                           // radius set as attribute
    c.style.offsetPath = `path('${d}')`;
    setTimeout(()=>{ c.style.animation = `travel ${BALL_MS/1000}s linear 0s 1 forwards`; }, delay);
    svg.appendChild(c);
    return c;
  };
  const midBall = (x,y,good) => {
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('cx',x); c.setAttribute('cy',y);
    c.setAttribute('r','10');
    c.setAttribute('class', `mid ${good?'good pulse':'bad'}`);
    svg.appendChild(c); return c;
  };
  const leaf = (x,y) => {
    const c = document.createElementNS(NS,'circle');
    c.setAttribute('cx',x); c.setAttribute('cy',y);
    c.setAttribute('r','12');
    c.setAttribute('class','leaf');
    svg.appendChild(c); return c;
  };

  // First layer edges + tokens
  const first = [];
  const firstXStart = root.x - span1/2;
  for (let i=0;i<N;i++){
    const x = firstXStart + (span1/(N-1))*i;
    const d = pathD(root.x, root.y+28, x, y1);
    const e = drawEdge(d);
    const startDelay = i*STAGGER_MS;
    animateDraw(e, startDelay);
    token(d, startDelay + DRAW_MS*0.4);
    first.push({x, d, edge:e});
  }

  // After first layer drawn — pick top-M and show mid balls (green/red)
  const firstLayerDone = (N-1)*STAGGER_MS + DRAW_MS + 100;
  setTimeout(()=>{
    // deterministic center-out winners (replace with random if you prefer)
    const order = [...Array(N).keys()].sort((a,b)=>Math.abs(a-(N-1)/2)-Math.abs(b-(N-1)/2));
    const winnersIdx = order.slice(0, M).sort((a,b)=>a-b);

    const winners = [];
    first.forEach((node, idx)=>{
      const isWinner = winnersIdx.includes(idx);
      midBall(node.x, y1, isWinner);
      if (isWinner) winners.push(node);
    });

    // Expand only winners
    const leaves = [];
    winners.forEach((w, wi)=>{
      const baseX = w.x - span2/2;
      for (let c=0;c<CHILDREN;c++){
        const x2 = baseX + (span2/(CHILDREN-1))*c;
        const d2 = pathD(w.x, y1+10, x2, y2);
        const e2 = drawEdge(d2);
        const delay = wi*CHILDREN*STAGGER_MS + c*STAGGER_MS;
        animateDraw(e2, delay);
        token(d2, delay + DRAW_MS*0.4);
        leaves.push(leaf(x2, y2));
      }
    });

    // Final: choose one green winner among leaves (others red) — once
    const finalPickAt = winners.length*CHILDREN*STAGGER_MS + DRAW_MS + 200;
    setTimeout(()=>{
      const winIdx = 0; // deterministic left-most; swap to Math.random() for randomness
      leaves.forEach((l, i)=>{
        if (i===winIdx){ l.classList.add('good','pulse'); }
        else { l.classList.add('bad'); }
      });
    }, finalPickAt);

  }, firstLayerDone);
}

// Auto-start once when the SVG scrolls into view
document.addEventListener('DOMContentLoaded', () => {
  const target = document.getElementById('beam');
  if (!target) return;
  if (!('IntersectionObserver' in window)) { startBeam(); return; }
  const obs = new IntersectionObserver(
    entries => { if (entries[0]?.isIntersecting) { startBeam(); obs.disconnect(); } },
    { threshold: 0.25 }
  );
  obs.observe(target);
});
</script>

<h3 style="margin:1.25rem 0 0.5rem 0; font-size:1.25rem; font-weight:700;">Diverse Verifier Tree Search</h3>

  <p>Unlike standard beam search, where all candidates share a single prefix and compete within the same pool, Diverse Verifier Tree Search 
    ensures that different subtrees evolve on their own. </p>
    
    <p>This separation encourages the search to explore a wider variety of reasoning paths instead of collapsing too quickly on similar solutions.</p>
    <p>Starting from an initial set of beams, the algorithm splits them into separate subtrees that are expanded independently.</p>
   <p>At each step, a reward model evaluates the partial solutions and guides which branches to keep growing.</p>


<div class="wrap">
  <h1>Diverse Verifier Tree Search</h1>
  <p class="sub">Split beams into independent subtrees → verifier selects the best step in each → expand and choose final answers.</p>
  <svg id="diverse" viewBox="0 0 1200 400"></svg>
</div>

<script>
function startDiverse(){
  const NS  = 'http://www.w3.org/2000/svg';
  const svg = document.getElementById('diverse');
  if (!svg || svg.dataset.started === '1') return;
  svg.dataset.started = '1';
  svg.innerHTML = '';

  // ---- Tunables ----
  const TREES = 2;          // how many subtrees
  const CHILDREN = 2;       // leaves per subtree
  const DRAW_MS = 700;
  const STAGGER_MS = 150;
  const BALL_MS = 1400;

  // Layout
  const root = {x:600,y:70};
  const y1=180, y2=320;
  const span=400; // spacing between subtrees

  // Root node
  const gRoot = document.createElementNS(NS,'g');
  gRoot.setAttribute('transform',`translate(${root.x-80},${root.y-28})`);
  const r = document.createElementNS(NS,'rect');
  r.setAttribute('width',160); r.setAttribute('height',56); r.setAttribute('rx',18);
  r.setAttribute('fill','var(--node)'); r.setAttribute('class','node');
  const t = document.createElementNS(NS,'text');
  t.setAttribute('x',80); t.setAttribute('y',34); t.setAttribute('text-anchor','middle');
  t.textContent='Math problem';
  gRoot.appendChild(r); gRoot.appendChild(t); svg.appendChild(gRoot);

  // Helpers
  const pathD=(x1,y1,x2,y2)=>{
    const midX=(x1+x2)/2,bendY=(y1+y2)/2;
    return `M ${x1} ${y1} C ${midX} ${bendY}, ${midX} ${bendY}, ${x2} ${y2}`;
  };
  const drawEdge=(d)=>{
    const p=document.createElementNS(NS,'path');
    p.setAttribute('d',d);p.setAttribute('class','edge draw');svg.appendChild(p);
    const len=p.getTotalLength();p.style.strokeDasharray=`${len}`;p.style.strokeDashoffset=`${len}`;
    return {path:p,len};
  };
  const animateDraw=(edge,delay=0)=>{setTimeout(()=>{edge.path.style.strokeDashoffset='0';},delay)};
  const token=(d,delay=0)=>{
    const c=document.createElementNS(NS,'circle');
    c.setAttribute('r','8');c.setAttribute('class','token');
    c.style.offsetPath=`path('${d}')`;
    setTimeout(()=>{c.style.animation=`travel ${BALL_MS/1000}s linear 0s 1 forwards`;},delay);
    svg.appendChild(c);return c;
  };
  const midBall=(x,y,good)=>{
    const c=document.createElementNS(NS,'circle');
    c.setAttribute('cx',x);c.setAttribute('cy',y);c.setAttribute('r','10');
    c.setAttribute('class',`mid ${good?'good pulse':'bad'}`);svg.appendChild(c);return c;
  };
  const leaf=(x,y)=>{
    const c=document.createElementNS(NS,'circle');
    c.setAttribute('cx',x);c.setAttribute('cy',y);c.setAttribute('r','12');
    c.setAttribute('class','leaf');svg.appendChild(c);return c;
  };

  // Create subtrees
  const subtreeCenters=[root.x-span/2, root.x+span/2];
  const allLeaves=[];

  subtreeCenters.forEach((cx,i)=>{
    const d=pathD(root.x,root.y+28,cx,y1);
    const e=drawEdge(d);
    animateDraw(e,i*STAGGER_MS);
    token(d,i*STAGGER_MS+DRAW_MS*0.4);

    // Pick a winner at intermediate level (deterministic: left subtree good, right subtree bad)
    const isWinner=true;
    midBall(cx,y1,isWinner);

    // Expand children
    const baseX=cx-120;
    for(let j=0;j<CHILDREN;j++){
      const x2=baseX+(240/(CHILDREN-1))*j;
      const d2=pathD(cx,y1+10,x2,y2);
      const e2=drawEdge(d2);
      animateDraw(e2,j*STAGGER_MS+200);
      token(d2,j*STAGGER_MS+DRAW_MS*0.4+200);
      allLeaves.push(leaf(x2,y2));
    }
  });

  // Final pick: one green leaf per subtree
  const finalPickAt=DRAW_MS*2+500;
  setTimeout(()=>{
    // deterministically choose left-most of each subtree
    const leavesPerTree=CHILDREN;
    allLeaves.forEach((l,i)=>{
      if(i%leavesPerTree===0){l.classList.add('good','pulse');}
      else{l.classList.add('bad');}
    });
  },finalPickAt);
}

// Auto-start once on scroll into view
document.addEventListener('DOMContentLoaded',()=>{
  const target=document.getElementById('diverse');
  if(!target)return;
  if(!('IntersectionObserver'in window)){startDiverse();return;}
  const obs=new IntersectionObserver(
    entries=>{if(entries[0]?.isIntersecting){startDiverse();obs.disconnect();}},
    {threshold:0.25}
  );
  obs.observe(target);
});
</script>

<h3 style="margin:1.25rem 0 0.5rem 0; font-size:1.25rem; font-weight:700;">Strategies performance comparison</h3>

  <p>When applying reasoning strategies to language models, it is important to understand how different approaches trade off between 
    accuracy, diversity, and compute cost.</p>
    
    <p>Methods like Best-of-N, Beam Search, and Diverse Verifier Tree Search all leverage verifier feedback in different ways,
       and comparing their performance highlights which strategies scale most effectively as we increase the number of generations.</p>

<h1>Strategies Performance Comparison</h1>
<svg id="chart" viewBox="0 0 900 540"></svg> <!-- a bit taller to fit bottom legend -->

<script>
(function(){
  // ---- Data ---------------------------------------------------------------
  const series = {
    Majority:        [[2,27],[4,33],[8,38],[16,41],[32,44],[64,45],[128,46]],
    "Best-of-N":     [[2,28],[4,36],[8,40],[16,43],[32,45],[64,48],[128,49]],
    "Beam search":   [[2,29],[4,38],[8,44],[16,49],[32,51],[64,52],[128,53]],
    DVTS:            [[2,28],[4,39],[8,42],[16,47],[32,51],[64,55],[128,56]],
  };
  const colors = {
    Majority:"#3b82f6",
    "Best-of-N":"#f59e0b",
    "Beam search":"#22c55e",
    DVTS:"#ef4444"
  };

  // ---- Layout -------------------------------------------------------------
  const svg = d3.select("#chart");
  const margin = {top:30, right:20, bottom:90, left:60}; // extra bottom for legend
  const width  = 900 - margin.left - margin.right;
  const height = 540 - margin.top - margin.bottom;

  // Guard to run once
  function started(){ return svg.attr("data-started")==="1"; }
  function markStarted(){ svg.attr("data-started","1"); }

  function startChart(){
    if (started()) return;
    markStarted();

    const root = svg.append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    const x = d3.scaleLog().domain([2,128]).range([0,width]);
    const y = d3.scaleLinear().domain([25,60]).range([height,0]);

    // Axes
    root.append("g")
      .attr("transform",`translate(0,${height})`)
      .attr("class","axis")
      .call(d3.axisBottom(x).ticks(7,",d"));
    root.append("g")
      .attr("class","axis")
      .call(d3.axisLeft(y));

    // Labels
    root.append("text")
      .attr("x",width/2).attr("y",height+40)
      .attr("text-anchor","middle").text("Number of generations per problem");
    root.append("text")
      .attr("transform","rotate(-90)")
      .attr("x",-height/2).attr("y",-45)
      .attr("text-anchor","middle").text("MATH-500 accuracy (%)");

    // Baselines
    root.append("line")
      .attr("class","baseline").attr("x1",0).attr("x2",width)
      .attr("y1",y(29)).attr("y2",y(29));
    root.append("text").attr("x",width-4).attr("y",y(29)-6)
      .attr("text-anchor","end").text("Llama 3.2 1B");
    root.append("line")
      .attr("class","baseline").attr("x1",0).attr("x2",width)
      .attr("y1",y(51)).attr("y2",y(51));
    root.append("text").attr("x",width-4).attr("y",y(51)-6)
      .attr("text-anchor","end").text("Llama 3.1 8B");

    const line = d3.line()
      .x(d=>x(d[0]))
      .y(d=>y(d[1]))
      .curve(d3.curveMonotoneX);

    // Animate each series
    const names = Object.keys(series);
    names.forEach((name,i)=>{
      const values = series[name];
      const path = root.append("path")
        .datum(values)
        .attr("fill","none")
        .attr("stroke",colors[name])
        .attr("stroke-width",2)
        .attr("d",line);

      const L = path.node().getTotalLength();
      path.attr("stroke-dasharray", `${L} ${L}`)
          .attr("stroke-dashoffset", L)
        .transition()
          .duration(2500)
          .delay(i*350)
          .ease(d3.easeLinear)
          .attr("stroke-dashoffset", 0);

      // Dots that rise up from the bottom
      root.selectAll(`.dot-${i}`)
        .data(values).enter()
        .append("circle")
        .attr("class",`dot-${i}`)
        .attr("cx",d=>x(d[0]))
        .attr("cy",y(25)) // bottom start
        .attr("r",4)
        .attr("fill",colors[name])
        .transition().duration(2500).delay(i*350)
        .attr("cy",d=>y(d[1]));
    });

    // ---- Bottom legend (centered) ----------------------------------------
    const legend = root.append("g")
      .attr("class","legend")
      .attr("transform", `translate(${width/2}, ${height+60})`);

    const items = names.map((n,i)=>({name:n, color:colors[n]}));
    const spacing = 130;  // horizontal spacing between legend items
    const startX = -((items.length-1)*spacing)/2;

    const lg = legend.selectAll("g.item")
      .data(items).enter()
      .append("g")
      .attr("class","item")
      .attr("transform",(d,i)=>`translate(${startX + i*spacing},0)`);

    lg.append("circle").attr("r",5).attr("fill",d=>d.color).attr("cx",0).attr("cy",0);
    lg.append("text").text(d=>d.name).attr("x",10).attr("y",0);
  }

  // ---- Auto-start when scrolled into view --------------------------------
  document.addEventListener("DOMContentLoaded", ()=>{
    const el = document.getElementById("chart");
    if (!("IntersectionObserver" in window)) { startChart(); return; }
    const obs = new IntersectionObserver(
      entries => {
        if (entries[0]?.isIntersecting) {
          startChart();
          obs.disconnect();
        }
      },
      { threshold: 0.25 }
    );
    obs.observe(el);
  });
})();
</script>


<p><strong>to be continued</strong></p>
<br></br>
<br></br>

  <h1 style="text-align:left">How Good Are Models at Reasoning?</h1>
  <h2>Benchmarks</h2>
  <p>
    Benchmarks are widely used to evaluate the capabilities of large language models (LLMs).
    They consist of curated problem sets focused on specific skills - such as mathematics, programming, scientific understanding, or medical diagnostics.
    By testing models on these tasks, we get a snapshot of their reasoning power and generalization abilities.
  </p>
  <h3>Benchmark Reasoning Categories</h3>
  <p>
    Please see the description of possible problem sets in the table below. Each category represents a distinct type of reasoning  challenge used in 
    benchmark evaluations. You can search through the table by typing keywords (e.g. <em>"math"</em>, <em>"medical"</em>, <em>"code"</em>) into the
    search bar in the top-right corner of the table.
  </p>
    <table id="benchmark-table" class="display">
      <thead>
        <tr>
          <th>Category</th>
          <th>Description</th>
          <th>Benchmarks</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Math Problems</td>
          <td>Solves mathematical problems showcasing capabilities of reasoning LLMs.</td>
          <td>AIME, MATH-500, OlympiadBench</td>
        </tr>
        <tr>
          <td>Code Problems</td>
          <td>Uses logical thinking and structured problem-solving in programming tasks.</td>
          <td>Codeforces, LiveCodeBench</td>
        </tr>
        <tr>
          <td>Scientific Problems</td>
          <td>Involves multi-domain reasoning across physics, chemistry, and biology.</td>
          <td>GPQA Diamond, MMLU-Pro</td>
        </tr>
        <tr>
          <td>Agent Reasoning</td>
          <td>Tests planning and decision-making in interactive and tool-using environments.</td>
          <td>WebShop, WebArena, SciWorld</td>
        </tr>
        <tr>
          <td>Medical Reasoning</td>
          <td>Mimics diagnostic reasoning and treatment planning in clinical contexts.</td>
          <td>MedQA, Medbullets</td>
        </tr>
        <tr>
          <td>Multimodal Reasoning</td>
          <td>Combines text and visual input to test cross-modal reasoning skills.</td>
          <td>MMMU, MathVista, MM-IQ</td>
        </tr>
      </tbody>
    </table>
    <br>
      A strong model is expected to perform well across multiple diverse benchmarks, demonstrating not just memorization or task-specific tricks, but real, 
      transferable reasoning. In this way, benchmarks help define what it means for a model to be universal rather than narrowly overfitted.
    <br>
    <script>
      $(document).ready(function () {
        $('#benchmark-table').DataTable({
          paging: false,
          info: false,
          language: {
            search: "🔍 Search benchmarks:"
          }
        });
      });
    </script>

<body>
  <h3>State-of-the-Art Model Performance on Benchmarks</h3>
  <p>
    The following table shows Pass@1 or Percentile scores across several benchmark tasks.
  </p>
  <table id="benchmarkTable" class="display">
    <thead>
      <tr>
        <th>Benchmark</th>
        <th>Metric</th>
        <th>DeepSeek-R1</th>
        <th>OpenAI-o1-1217</th>
        <th>DeepSeek-R1-32B</th>
        <th>OpenAI-o1-mini</th>
        <th>DeepSeek-V3</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>AIME 2024</td>
        <td>Pass@1</td>
        <td>79.8%</td>
        <td>79.2%</td>
        <td>72.6%</td>
        <td>63.6%</td>
        <td>39.2%</td>
      </tr>
      <tr>
        <td>Codeforces</td>
        <td>Percentile</td>
        <td>96.3%</td>
        <td>96.6%</td>
        <td>90.6%</td>
        <td>93.4%</td>
        <td>58.7%</td>
      </tr>
      <tr>
        <td>GPQA Diamond</td>
        <td>Pass@1</td>
        <td>71.5%</td>
        <td>75.7%</td>
        <td>62.1%</td>
        <td>60.0%</td>
        <td>59.1%</td>
      </tr>
      <tr>
        <td>MATH-500</td>
        <td>Pass@1</td>
        <td>97.3%</td>
        <td>96.4%</td>
        <td>94.3%</td>
        <td>90.0%</td>
        <td>90.2%</td>
      </tr>
      <tr>
        <td>MMLU</td>
        <td>Pass@1</td>
        <td>90.8%</td>
        <td>91.8%</td>
        <td>87.4%</td>
        <td>85.2%</td>
        <td>88.5%</td>
      </tr>
      <tr>
        <td>SWE-bench Verified</td>
        <td>Resolved</td>
        <td>49.2%</td>
        <td>48.9%</td>
        <td>41.6%</td>
        <td>36.8%</td>
        <td>42.0%</td>
      </tr>
    </tbody>
  </table>

  <p class="citation">(DeepSeek-AI et al., 2025)</p>

  <script>
    $(document).ready(function () {
      $('#benchmarkTable').DataTable({
        paging: false,
        info: false,
        responsive: true,
        language: {
          search: "🔍 Search benchmarks:"
        }
      });
    });
  </script>

<hr>

<h3>The Problem With Benchmarks</h3>
<p>Despite their usefulness, traditional benchmarks are facing growing criticism.</p>

<p>
  Task difficulty is often hard to define. What makes a problem "difficult" is often subjective. This makes it tricky to scale problem sets meaningfully 
  or test a model's performance on progressively harder tasks.
</p>
<p>
  Another concern is data leakage from training corpora. Many benchmark problems have ended up in the training data of large models, whether intentionally or not. 
  This makes it unclear whether the model is reasoning through a solution — or simply memorizing and regurgitating it.
</p>

<h2>Puzzle-Based Benchmarks</h2>
<p><em>Shojaee et al., 2025</em></p>
<p>
  To address these limitations, researchers are exploring alternative benchmarks. One compelling direction is using puzzle-like problems, such as the 
  Tower of Hanoi, where complexity can be precisely controlled — by simply increasing the number of disks. In this setup, models are evaluated not just 
  on their accuracy, but on how well they scale with increasing task difficulty.
</p>

<div class="hanoi-section">
<h4>Tower of Hanoi (3 Disks)</h4>
<p>Auto-solving animation (A → C)</p>

<div class="peg-container">
  <div class="peg" id="pegA"></div>
  <div class="peg" id="pegB"></div>
  <div class="peg" id="pegC"></div>
</div>

<div class="peg-container">
  <div class="peg-label">A</div>
  <div class="peg-label">B</div>
  <div class="peg-label">C</div>
</div>

<script>
  const pegs = {
    A: document.getElementById('pegA'),
    B: document.getElementById('pegB'),
    C: document.getElementById('pegC'),
  };

  const disks = [
    { class: 'disk1', size: 3 },
    { class: 'disk2', size: 2 },
    { class: 'disk3', size: 1 },
  ];

  let state;

  const sleep = (ms) => new Promise(res => setTimeout(res, ms));

  function resetPegs() {
    // Clear pegs
    pegs.A.innerHTML = '';
    pegs.B.innerHTML = '';
    pegs.C.innerHTML = '';

    // Reset state
    state = { A: [], B: [], C: [] };

    // Add disks back to peg A
    disks.forEach((d, i) => {
      const el = document.createElement('div');
      el.className = `disk ${d.class}`;
      el.style.bottom = `${i * 22}px`;
      pegs.A.appendChild(el);
      state.A.push(el);
    });
  }

  async function move(n, from, to, aux) {
    if (n === 0) return;
    await move(n - 1, from, aux, to);

    await sleep(800);
    const disk = state[from].pop();
    state[to].push(disk);
    pegs[to].appendChild(disk);
    disk.style.bottom = `${(state[to].length - 1) * 22}px`;

    await move(n - 1, aux, to, from);
  }

  async function loopHanoi() {
    while (true) {
      resetPegs();
      await move(3, 'A', 'C', 'B');
      await sleep(1000); // pause before restarting
    }
  }

  // Start looping animation
  loopHanoi();
</script>

</div>

<h3>When Reasoning Models Collapse</h3>
<p>
  A surprising trend emerges as task complexity increases: reasoning-tuned models initially outperform their baseline counterparts, 
  but beyond a certain threshold, both collapse in performance. This sharp decline challenges assumptions about the robustness of current 
  reasoning models and exposes their fragility under higher cognitive demands.
</p>

<h4 style="text-align: center;">Model Accuracy vs. Task Complexity</h4>
<canvas id="accuracyChart" class="chart-on-scroll" width="700" height="400"></canvas>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  function renderAccuracyChart() {
  const ctx = document.getElementById('accuracyChart').getContext('2d');

  new Chart(ctx, {
    type: 'line',
    data: {
      labels: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20],
      datasets: [
        {
          label: 'DeepSeek-R1',
          data: [100, 98, 95, 90, 85, 70, 60, 10, 2, 1, 0, 0],
          borderColor: '#4ECDC4',
          backgroundColor: 'transparent',
          tension: 0.3
        },
        {
          label: 'DeepSeek-V3',
          data: [98, 97, 96, 85, 30, 20, 10, 5, 1, 0, 0, 0],
          borderColor: '#FF6B6B',
          backgroundColor: 'transparent',
          tension: 0.3
        }
      ]
    },
    options: {
      responsive: true,
      animation: {
        duration: 2500,
        easing: 'easeOutQuart'
      },
      plugins: {
        legend: {
          position: 'bottom'
        },
        title: {
          display: false
        }
      },
      scales: {
        y: {
          beginAtZero: false,
          max: 100,
          title: {
            display: true,
            text: 'Accuracy (%)'
          }
        },
        x: {
          title: {
            display: true,
            text: 'Task Complexity'
          }
        }
      }
    }
  });
  }
</script>

<script>
  const observer = new IntersectionObserver((entries, observer) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        if (entry.target.id === 'accuracyChart') {
          renderAccuracyChart();
        }
        observer.unobserve(entry.target); // only run once
      }
    });
  }, {
    threshold: 0.4 // Trigger when 40% visible
  });

  document.querySelectorAll('.chart-on-scroll').forEach(chart => {
    observer.observe(chart);
  });
</script>


<h3>Even With Help, They Struggle</h3>
<p>
  Interestingly, even when the model is given the solution in the prompt, performance doesn’t improve significantly.
  This suggests that the model doesn't simply fail to find a solution — it struggles to use or interpret one when given.
</p>

<h4 style="text-align: center;">Claude-3.7-Sonnet Performance</h4>
<canvas id="claudeChart" class="chart-on-scroll" width="700" height="400"></canvas>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- Chart render function -->
<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {

    function renderClaudeChart() {
      const ctx = document.getElementById('claudeChart').getContext('2d');

      new Chart(ctx, {
        type: 'line',
        data: {
          labels: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20],
          datasets: [
            {
              label: 'Default',
              data: [99.5, 99.5, 99.5, 99.5, 90, 55, 70, 15, 5, 2, 1, 1],
              borderColor: '#DE6E4B',
              borderWidth: 3,
              pointStyle: 'rect',
              pointRadius: 6,
              tension: 0.3
            },
            {
              label: 'Algorithm Given',
              data: [99.5, 99.5, 99.5, 99.5, 90, 70, 65, 10, 2, 1, 1, 1],
              borderColor: '#B0422F',
              borderDash: [6, 4],
              borderWidth: 3,
              pointStyle: 'circle',
              pointRadius: 6,
              tension: 0.3
            }
          ]
        },
        options: {
          responsive: true,
          animation: {
            duration: 1200,
            easing: 'easeOutQuart'
          },
          plugins: {
            legend: { position: 'bottom' },
            title: {
              display: true,
              text: 'Accuracy vs Complexity (Number of Disks)'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              title: { display: true, text: 'Accuracy (%)' }
            },
            x: {
              title: { display: true, text: 'Complexity (Number of Disks)' }
            }
          }
        }
      });
    }

    const observer = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.target.id === 'claudeChart') {
          renderClaudeChart();
          observer.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.4
    });

    document.querySelectorAll('.chart-on-scroll').forEach(chart => {
      observer.observe(chart);
    });

  });
</script>

<h3>A Curious Token Length Effect</h3>
<p>
  Another surprising effect: as task complexity grows, models tend to produce shorter outputs - even though longer answers 
  would likely lead to better performance. This indicates a possible failure in internal planning or token budgeting, challenging the assumption that more capable models
  will naturally expand their answers as needed.</p>

<h4 style="text-align: center;">o3-mini (high): Output Token Count vs Complexity</h4>
<canvas id="tokenChart" class="chart-on-scroll" width="700" height="400"></canvas>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {

    function renderTokenChart() {
      const ctx = document.getElementById('tokenChart').getContext('2d');

      new Chart(ctx, {
        type: 'line',
        data: {
          labels: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20],
          datasets: [
            {
              label: 'Average Token Count',
              data: [500, 900, 2000, 4500, 8500, 20000, 18000, 12000, 7000, 5000, 3000, 2000],
              borderColor: '#0077BB',
              borderDash: [6, 4],
              borderWidth: 3,
              fill: false,
              tension: 0.3,
              pointRadius: 6,
              pointStyle: 'circle',
              backgroundColor: 'transparent'
            },
            {
              label: 'Individual Runs',
              type: 'scatter',
              data: [
                { x: 4, y: 4300 }, { x: 4, y: 4700 }, { x: 5, y: 8800 },
                { x: 5, y: 8000 }, { x: 6, y: 19500 }, { x: 6, y: 20500 },
                { x: 7, y: 18000 }, { x: 7, y: 17500 }, { x: 8, y: 11000 },
                { x: 9, y: 7500 }, { x: 9, y: 6900 }, { x: 10, y: 4500 },
                { x: 15, y: 3100 }, { x: 15, y: 2900 }, { x: 20, y: 2100 }
              ],
              backgroundColor: '#E63946',
              pointRadius: 4,
              showLine: false
            }
          ]
        },
        options: {
          responsive: true,
          animation: {
            duration: 1500,
            easing: 'easeOutQuart'
          },
          plugins: {
            legend: {
              position: 'bottom'
            },
            title: {
              display: true,
              text: 'Output Length vs. Complexity (Number of Disks)'
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Output Tokens'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Complexity (Number of Disks)'
              }
            }
          }
        }
      });
    }

    const observer = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.target.id === 'tokenChart') {
          renderTokenChart();
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.4 });

    document.querySelectorAll('.chart-on-scroll').forEach(chart => {
      observer.observe(chart);
    });

  });
</script>


<h2>Open Questions Remain</h2>
<p>
  To what extent can current models really reason? While benchmarks remain a useful tool, these findings highlight the fragility of current 
  approaches and the limitations of today's so-called “reasoning models.” There is still a long road ahead to build systems that reason 
  reliably under increasing task difficulty — and to prove that their reasoning is more than just a memorized pattern.
</p>

</body>
</html>
